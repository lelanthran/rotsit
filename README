
Revenge of the SIT
------------------

A rewrite of the original Simple Issue Tracker. The issue tracker works
with a text file that can be stored in version control. Text utilities
must work on this textfile (diff/merge, etc) to allow the VCS (version
control system) to manage the issues.



File format
-----------

The issues database is stored in a plain text file. No header exists for
this file. The file consists of a list of records. Each records consists
of a list of fields. All fields are plain ascii text only, with the bytes
0x00 and 0x08 reserved for use by the program.

Records are delimited by the character sequence "f\b\n". Fields are
delimited by the character sequence "f\b".



Expression parsing
------------------

When listing records the caller should be able to specify a natural
language (ish) expression:

(field1 > value1 and field2 < value2)     # expr1, expr2
   or (field3 = value3)                   # expr3
   or (field4 != value4)                  # expr4

operator:   > | < | == | != | OR | AND
operand:    string
expr:       operand operator operand
node:       expr | (expr)

Each node in the tree will return either a true or a false for a given
field, this bool is propogated up the tree. The above example becomes are
tree that looks like this:

  (OR) -+---------> (AND) -+---1----> (>) -+------> field1
        |                  |               |
        |                  |               +------> value1
        |                  |
        |                  |
        |                  +---2----> (<) -+------> field2
        |                                  |
        |                                  +------> value2
        |
        +----3-----> (=) -+------> field3
        |                 |
        |                 +------> value3
        |
        |
        |
        +----4----> (!=) -+------> field4
                          |
                          +------> value4

This isn't as easy as it looks. For example, changing the example
expression to (note emphasis):

(field1 > value1 and field2 < value2)     # expr1, expr2
   AND (field3 = value3)                  # expr3
   or (field4 != value4)                  # expr4

Breaks the tree building process. The problem is that operators OR and AND
do not have only two children. We can fix this by breaking out the OR and
AND conjunctions so that they are not operators, in which case every
single OR and every single AND must be enclosed by brackets.

operator:   > | < | == | !=
operand:    string
conj:       and | or
expr:       operand operator operand
node:       expr | (expr conj expr)

When an open bracket is encountered a new CONJUNCTION node must be created
that will only contain two children. At the end of any expression we must
return a tree to parent who can examine the next token and decide how to
join the next tree to the current token.

We can recursively parse this into a tree easily:

struct node_t {
   uint8_t  op;         # Either >, <, ==, !=, AND, OR or NONE
   node_t  *lhs;
   node_t  *rhs;
};

eval ("field1") => { NONE, "field1", NULL };
eval ("x", "OP", "y") => { OP, "x", "y" };

We should recursively descend the tree to parse the input tokens. Pattern
matching is a bit clunky.

Maybe push each token onto a stack. When end-of-expr is detected we
pop the last infix expression on the stack, evaluate it and push the
result back?

(
field1
>
value1
AND      <= Pop rhs, op, lhs then push { >, field1, value1 }, push AND
--------------------


   (
   t/f
   AND
field2
<
value2
)        <= Pop rhs, op, lhs then push { < field2, value2 }, push ')'
--------------------


   (
   t/f
   AND
   t/f
   )     <= Eval stack as [r] OP [r] until '(' reached
--------------------


   t/f
AND      <= Pop rhs, op, lhs, fail and continue, push AND
--------------------


   t/f
   AND
field3
=
value3
OR       <= Pop rhs, op, lhs then push { =, field3, value3 }, push OR
--------------------


   t/f
   AND
   t/f
   OR    <= Eval stack
--------------------

   t/f
   OR
field4
!=
value4
EOF      <= Eval stack
--------------------


t/f      <= result


stack_item_t must hold the following types:
conjunction:   AND, OR
operator:      >, <, ==, !=
operand:       string/reference
result:        true/false
delim:         '(' and ')'

void eval_last (stack_t *stack) {
   rhs = pop (stack);
   op = pop (stack);
   lhs = pop (stack);
   if (!lhs || !op || !rhs) {
      push_null (stack, lhs);    // Does nothing if lhs is NULL
      push_null (stack, op);     // Does nothing if op is NULL
      push_null (stack, rhs);    // Does nothing if rhs is NULL
   } else {
      push (stack, runop (op, lhs, rhs));
   }
}

void eval_braces (stack_t *stack) {
   next = peek (stack);
   while (next && next!='(') {
      eval_last (stack);
      next = peek (stack);
   }
}

void eval_stack (stack_t *stack) {

   while (count (stack) > 1) {
      rhs = pop (stack);
      op = pop (stack);
      lhs = pop (stack);
      if (!op || !lhs) {
         error ("Expression truncated\n");
      } else {
         push (stack, runop (op, lhs, rhs));
      }
   }

   // Single item on stack is the result
}


Parsing general arithmetic expressions
--------------------------------------
Using two stacks we can evaluate any arithmetic expression (boolean
filters are a specialised instance of general arithmetic) while
implementing precedence.

One stack holds the operands, the other holds the operators. Each time we
encounter a CLOSE token (either ')'  or ']' or similar) pop two operands
and the last operator and evaluate that single expression. We then push
the result back onto the operand stack and continue. Each time we
encounter a "*" or "/" operator we pop one operand and one operator and
apply the expression and push the result onto the operand stack.

Once we get to the end of the input we repeatedly pop 2 operands and 1
operator, applying the operator to the operand and pushing the result into
the operand stack.

(field1 > value1 and field2 < value2)     # expr1, expr2
   or (field3 == value3)                  # expr3
   or field4 != value4                    # expr4

st1                     st2               token[i]
                                          (
                                          field1
field1                                    >
field1                  >                 value1
field1,value1           >                 )
TF                                        and
TF                      AND               field2
TF,field2               AND               <
TF,field2               AND,<             value2
TF,field2,value2        AND,<             )
TF,TF                   AND               or
TF,TF                   AND,OR            (
TF,TF                   AND,OR            field3
TF,TF,field3            AND,OR            ==
TF,TF,field3            AND,OR,==         value3
TF,TF,field3,value3     AND,OR,==         )
TF,TF,TF                AND,OR            or
TF,TF,TF                AND,OR,OR         field4
TF,TF,TF,field4         AND,OR,OR         !=
TF,TF,TF,field4         AND,OR,OR,!=      value4
TF,TF,TF,field4,value4  AND,OR,OR,!=      EOF
TF,TF,TF,TF             AND,OR,OR
TF,TF,TF                AND,OR
TF,TF                   AND
TF


// Caller must supply run_op (void *, void *, void *) and
// token_type (void *)
//
bool apply (st1, st2) {
   rhs = pop (st1);
   lhs = pop (st1);
   op = pop (st2);
   if (!lhs || !rhs || !op) {
      return false;
   }
   return push (st1, run_op (op, lhs, rhs)) ? true : false;
}

// We (maybe) use close_op to enforce closing brace to be the same as the
// opening one. There is no need for this, however it does allow the
// writer to attempt to enforce layers of braces.
void *eval (void *tokens[]) {
   for (i=0; tokens[i]; i++) {

      switch (token_type (tokens[i])) {

         // High precedence operators = immediate execution
         case MUL_DIV:  push (st1, tokens[i]);
                        push (st2, tokens[i]);
                        if (!apply (st1, st2))
                           return NULL;
                        break;

         // Can execute this at the end
         case LOW_OPS:  push (st2, tokens[i]);
                        break;

         case OPERAND:  push (st1, tokens[i]);
                        break;

         case OPEN:     close_op = tokens[i];
                        break;

         case CLOSE:    apply (st1, st2);
                        break;
   }
   while (length (st1)>=2 && length (st2))
      if (!apply (st1, st2))
         return NULL;

   if (length(st1)!=1 || length(st2)!=0)
      return NULL;

   return pop (st1);
}


Parsing into a tree
-------------------
We can generalise parsing for any arithmetic expression (booleans is a
specialised instance of arithmetic parsing) including precedence as
using a LL(1) grammar like this:

   op_add:  + | -
   op_mul:  * | /
   term:    string | number
   hexpr:   term op_mul term
   lexpr:   hexpr op_mul hexpr
   open:    ( | [ | {
   close:   ) | ] | }
   expr:    hexpr | lexpr | ( expr )

This is actually more complex and error-prone than the stack solution.


